<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SymplecticGeometryHub</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen", "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif;
            line-height: 1.6;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #ffffff;
        }
        
        h1 {
            color: #24292e;
            border-bottom: 1px solid #e1e4e8;
            padding-bottom: 10px;
        }
        
        p {
            color: #586069;
            margin-bottom: 16px;
        }
        
        .update-status {
            background: #f6f8fa;
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
            border-left: 4px solid #28a745;
            font-size: 14px;
        }
        
        .update-status.updating {
            border-left-color: #ffc107;
            background: #fff8e1;
        }
        
        .update-status.error {
            border-left-color: #dc3545;
            background: #f8d7da;
        }
        
        .update-status.loading {
            border-left-color: #007bff;
            background: #e7f3ff;
        }
        
        .search-box {
            margin: 20px 0;
        }
        
        .search-input {
            width: 100%;
            padding: 12px 15px;
            font-size: 16px;
            border: 2px solid #d0d7de;
            border-radius: 6px;
            outline: none;
            transition: border-color 0.2s;
            box-sizing: border-box;
        }
        
        .search-input:focus {
            border-color: #0366d6;
        }
        
        a {
            color: #0366d6;
            text-decoration: none;
        }
        
        a:hover {
            text-decoration: underline;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        
        th, td {
            border: 1px solid #d0d7de;
            padding: 8px 12px;
            text-align: left;
        }
        
        th {
            background-color: #f6f8fa;
            font-weight: 600;
        }
        
        tbody tr:nth-child(even) {
            background-color: #f6f8fa;
        }
        
        tbody tr:hover {
            background-color: #e6f3ff;
        }
        
        .highlight {
            background-color: #fff3cd;
            padding: 2px 4px;
            border-radius: 3px;
            font-weight: bold;
        }
        
        .no-results {
            text-align: center;
            padding: 40px;
            color: #586069;
            font-style: italic;
            display: none;
        }
        
        .footer {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #e1e4e8;
            text-align: center;
            color: #586069;
            font-style: italic;
        }
        
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #0366d6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .auto-update-controls {
            background: #e6f3ff;
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .auto-update-controls button {
            background: #0366d6;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .auto-update-controls button:hover {
            background: #0256cc;
        }
        
        .auto-update-controls button:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }
        
        .new-article {
            background-color: #d4edda !important;
            animation: fadeIn 0.5s ease-in;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .csv-info {
            background: #f0f9ff;
            border: 1px solid #0ea5e9;
            border-radius: 6px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .csv-info h3 {
            margin: 0 0 10px 0;
            color: #0369a1;
        }
    </style>
    <!-- Importation de PapaParse depuis CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
</head>
<body>
    <h1>Collection of Articles on Symplectic Geometry</h1>
    
    <p>This list is automatically loaded from <code>symplectic_geometry_articles.csv</code> and includes hundreds of recent papers related to symplectic geometry, coisotropic submanifolds, Poisson structures, and related topics from arXiv.org.</p>
    
    <div class="csv-info">
        <h3>üìä CSV Data Source</h3>
        <p>Articles are automatically loaded from: <strong>symplectic_geometry_articles.csv</strong></p>
        <p>This database contains hundreds of research papers from arXiv.org in symplectic geometry and related fields.</p>
        <p>Status: <span id="csvStatus">Loading...</span></p>
    </div>
    
    <div class="auto-update-controls">
        <span>üîÑ Auto-update:</span>
        <button id="toggleAutoUpdate">Enable Auto-Update</button>
        <button id="manualUpdate">Update Now</button>
        <button id="reloadCsv">Reload CSV</button>
        <span id="updateInterval">Every 30 minutes</span>
        <select id="intervalSelect">
            <option value="10">10 minutes</option>
            <option value="30" selected>30 minutes</option>
            <option value="60">1 hour</option>
            <option value="180">3 hours</option>
            <option value="360">6 hours</option>
        </select>
    </div>
    
    <div class="update-status" id="updateStatus">
        ‚úÖ Last updated: <span id="lastUpdate">Never</span> | 
        üìä Total articles: <span id="articleCount">Loading...</span> |
        ‚è∞ Next update: <span id="nextUpdate">Not scheduled</span>
    </div>
    
    <div class="search-box">
        <input type="text" class="search-input" id="searchInput" placeholder="üîç Search articles by title, authors, or date..." autocomplete="off">
    </div>
    
    <table id="articlesTable">
        <thead>
            <tr>
                <th>Date</th>
                <th>Authors</th>
                <th>Title</th>
                <th>Link</th>
            </tr>
        </thead>
        <tbody id="articlesBody">
            <!-- Articles will be loaded from CSV -->
        </tbody>
    </table>
    
    <div class="no-results" id="noResults">
        üîç No articles found matching your search.
    </div>
    
    <div class="footer">
        <p>ü§ñ Auto-updating page with CSV integration and live arXiv updates</p>
    </div>

    <script>
        // Configuration
        const CONFIG = {
            updateInterval: 30, // minutes
            maxArticles: 500, // Augment√© pour accommoder tous les articles du CSV
            csvFileName: 'symplectic_geometry_articles.csv',
            searchQueries: [
                'symplectic geometry',
                'lagrangian submanifold', 
                'moment map',
                'poisson geometry',
                'hamiltonian mechanics'
            ]
        };
        
        // State
        let autoUpdateEnabled = false;
        let updateTimer = null;
        let allArticles = [];
        let filteredArticles = [];
        let csvLoaded = false;
        
        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            setupEventListeners();
            loadCsvData();
        });
        
        async function loadCsvData() {
            try {
                updateCsvStatus('Loading CSV file...', 'loading');
                updateStatus('üìÅ Loading articles from CSV...', 'loading');
                
                // Lire le fichier CSV
                const csvContent = await window.fs.readFile(CONFIG.csvFileName, { encoding: 'utf8' });
                
                // Parser le CSV avec PapaParse
                const parsed = Papa.parse(csvContent, {
                    header: true,
                    dynamicTyping: true,
                    skipEmptyLines: true,
                    delimitersToGuess: [',', '\t', '|', ';']
                });
                
                if (parsed.errors.length > 0) {
                    console.warn('CSV parsing warnings:', parsed.errors);
                }
                
                // Convertir les donn√©es en format articles selon la structure du CSV fourni
                allArticles = parsed.data.map((row, index) => {
                    // Nettoyer les headers (enlever les espaces)
                    const cleanRow = {};
                    Object.keys(row).forEach(key => {
                        const cleanKey = key.trim();
                        cleanRow[cleanKey] = row[key];
                    });
                    
                    // Adapter selon la structure exacte du CSV fourni
                    const id = cleanRow.id || '';
                    const title = cleanRow.title || '';
                    const authors = cleanRow.authors || '';
                    const published_date = cleanRow.published_date || '';
                    const url = cleanRow.url || '';
                    const pdf = cleanRow.pdf || '';
                    
                    return {
                        id: `csv-article-${index}`,
                        date: published_date.toString().trim(),
                        authors: authors.toString().trim(),
                        title: title.toString().trim(),
                        link: url.toString().trim(),
                        arxivId: id.toString().trim(),
                        pdfUrl: pdf.toString().trim(),
                        element: null // Will be created when rendering
                    };
                }).filter(article => article.title && article.title !== 'undefined' && article.title !== ''); // Filtrer les lignes vides
                
                // Trier par date (plus r√©cent en premier)
                allArticles.sort((a, b) => new Date(b.date) - new Date(a.date));
                
                // Rendre les articles
                renderArticles();
                
                csvLoaded = true;
                updateCsvStatus(`‚úÖ Loaded ${allArticles.length} articles from CSV`, 'success');
                updateStatus(`‚úÖ Successfully loaded ${allArticles.length} articles from CSV`);
                updateLastUpdateTime();
                
            } catch (error) {
                console.error('Error loading CSV:', error);
                updateCsvStatus('‚ùå Error loading CSV file', 'error');
                updateStatus('‚ùå Failed to load CSV file. Please check the file exists.', 'error');
                
                // Charger des articles par d√©faut en cas d'erreur
                loadDefaultArticles();
            }
        }
        
        function renderArticles() {
            const tbody = document.getElementById('articlesBody');
            tbody.innerHTML = ''; // Vider le tableau
            
            allArticles.forEach(article => {
                const row = document.createElement('tr');
                
                // Formater le lien arXiv avec l'ID si disponible
                let linkHtml = '';
                if (article.link && article.arxivId) {
                    linkHtml = `<a href="${article.link}">arXiv:${article.arxivId}</a>`;
                } else if (article.link) {
                    // Fallback si on n'a que l'URL
                    if (article.link.includes('arxiv.org')) {
                        const arxivMatch = article.link.match(/(\d{4}\.\d{5}v?\d*)/);
                        const arxivId = arxivMatch ? arxivMatch[1] : article.link.split('/').pop();
                        linkHtml = `<a href="${article.link}">arXiv:${arxivId}</a>`;
                    } else {
                        linkHtml = `<a href="${article.link}">Link</a>`;
                    }
                } else {
                    linkHtml = 'No link';
                }
                
                row.innerHTML = `
                    <td>${article.date}</td>
                    <td>${article.authors}</td>
                    <td>${article.title}</td>
                    <td>${linkHtml}</td>
                `;
                
                tbody.appendChild(row);
                article.element = row;
            });
            
            filteredArticles = [...allArticles];
            updateArticleCount();
        }
        
        function loadDefaultArticles() {
            // Articles par d√©faut en cas d'√©chec de chargement du CSV
            allArticles = [
                {
                    id: 'default-1',
                    date: '2025-05-31',
                    authors: 'Default Author',
                    title: 'Default Article - Please check your CSV file (symplectic_geometry_articles.csv)',
                    link: 'http://arxiv.org/abs/default',
                    arxivId: 'default.00000v1',
                    pdfUrl: 'http://arxiv.org/pdf/default',
                    element: null
                }
            ];
            renderArticles();
        }
        
        function setupEventListeners() {
            // Auto-update toggle
            document.getElementById('toggleAutoUpdate').addEventListener('click', toggleAutoUpdate);
            
            // Manual update
            document.getElementById('manualUpdate').addEventListener('click', manualUpdate);
            
            // Reload CSV
            document.getElementById('reloadCsv').addEventListener('click', reloadCsv);
            
            // Interval change
            document.getElementById('intervalSelect').addEventListener('change', function() {
                CONFIG.updateInterval = parseInt(this.value);
                updateIntervalDisplay();
                if (autoUpdateEnabled) {
                    scheduleNextUpdate();
                }
            });
            
            // Search functionality
            document.getElementById('searchInput').addEventListener('input', performSearch);
        }
        
        function reloadCsv() {
            updateStatus('üîÑ Reloading CSV file...', 'updating');
            loadCsvData();
        }
        
        function toggleAutoUpdate() {
            const button = document.getElementById('toggleAutoUpdate');
            
            if (autoUpdateEnabled) {
                // Disable auto-update
                autoUpdateEnabled = false;
                if (updateTimer) clearInterval(updateTimer);
                button.textContent = 'Enable Auto-Update';
                updateStatus('Auto-update disabled');
                updateNextUpdateTime('Not scheduled');
            } else {
                // Enable auto-update
                autoUpdateEnabled = true;
                button.textContent = 'Disable Auto-Update';
                updateStatus('Auto-update enabled');
                scheduleNextUpdate();
                
                // Do initial update
                fetchNewArticles();
            }
        }
        
        function scheduleNextUpdate() {
            if (updateTimer) clearInterval(updateTimer);
            
            const intervalMs = CONFIG.updateInterval * 60 * 1000;
            updateTimer = setInterval(fetchNewArticles, intervalMs);
            
            const nextUpdate = new Date(Date.now() + intervalMs);
            updateNextUpdateTime(nextUpdate.toLocaleTimeString());
        }
        
        function manualUpdate() {
            updateStatus('Updating manually...', 'updating');
            fetchNewArticles();
        }
        
        async function fetchNewArticles() {
            try {
                updateStatus('üîÑ Fetching new articles...', 'updating');
                
                // Simuler la r√©cup√©ration de nouveaux articles depuis arXiv
                const newArticles = await simulateArxivFetch();
                
                if (newArticles.length > 0) {
                    addNewArticles(newArticles);
                    updateStatus(`‚úÖ Found ${newArticles.length} new articles`);
                } else {
                    updateStatus('‚úÖ No new articles found');
                }
                
                updateLastUpdateTime();
                
            } catch (error) {
                console.error('Update failed:', error);
                updateStatus('‚ùå Update failed. Will retry later.', 'error');
            }
        }
        
        async function simulateArxivFetch() {
            // Simuler le d√©lai r√©seau
            await new Promise(resolve => setTimeout(resolve, 1500));
            
            // Simuler la d√©couverte de nouveaux articles parfois (30% de chance)
            const shouldFindNew = Math.random() > 0.7;
            
            if (shouldFindNew) {
                const now = new Date();
                const dateStr = now.toISOString().split('T')[0];
                const randomId = Math.floor(Math.random() * 99999);
                
                return [
                    {
                        date: dateStr,
                        authors: 'New Researcher, Co-Author Name',
                        title: `Recent Advances in Symplectic Topology (Simulated Article ${randomId})`,
                        link: `<a href="http://arxiv.org/abs/2505.${randomId}v1">arXiv:2505.${randomId}v1</a>`
                    }
                ];
            }
            
            return [];
        }
        
        function addNewArticles(newArticles) {
            const tbody = document.getElementById('articlesBody');
            let addedCount = 0;
            
            newArticles.forEach(article => {
                // V√©rifier si l'article existe d√©j√†
                const exists = allArticles.some(existing => 
                    existing.title === article.title || 
                    existing.authors === article.authors
                );
                
                if (!exists) {
                    // Cr√©er une nouvelle ligne
                    const row = document.createElement('tr');
                    row.className = 'new-article';
                    row.innerHTML = `
                        <td>${article.date}</td>
                        <td>${article.authors}</td>
                        <td>${article.title}</td>
                        <td>${article.link}</td>
                    `;
                    
                    // Ins√©rer en haut du tableau
                    tbody.insertBefore(row, tbody.firstChild);
                    
                    // Ajouter au tableau des articles
                    const newArticleObj = {
                        id: `article-new-${Date.now()}-${addedCount}`,
                        date: article.date,
                        authors: article.authors,
                        title: article.title,
                        link: article.link,
                        element: row
                    };
                    
                    allArticles.unshift(newArticleObj);
                    addedCount++;
                    
                    // Retirer la surbrillance apr√®s 5 secondes
                    setTimeout(() => {
                        row.classList.remove('new-article');
                    }, 5000);
                }
            });
            
            // Garder seulement les derniers articles (supprimer les plus anciens si trop nombreux)
            if (allArticles.length > CONFIG.maxArticles) {
                const toRemove = allArticles.splice(CONFIG.maxArticles);
                toRemove.forEach(article => {
                    if (article.element && article.element.parentNode) {
                        article.element.parentNode.removeChild(article.element);
                    }
                });
            }
            
            updateArticleCount();
            
            // Rafra√Æchir la recherche si active
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm) {
                performSearch();
            }
        }
        
        function performSearch() {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase().trim();
            const tbody = document.getElementById('articlesBody');
            const noResults = document.getElementById('noResults');
            
            let visibleCount = 0;
            
            allArticles.forEach(article => {
                const matchesSearch = !searchTerm || 
                    article.title.toLowerCase().includes(searchTerm) ||
                    article.authors.toLowerCase().includes(searchTerm) ||
                    article.date.includes(searchTerm);
                
                if (article.element) {
                    if (matchesSearch) {
                        article.element.style.display = '';
                        visibleCount++;
                        
                        // Surligner les termes de recherche
                        if (searchTerm) {
                            highlightSearchTerm(article.element, searchTerm);
                        } else {
                            removeHighlights(article.element);
                        }
                    } else {
                        article.element.style.display = 'none';
                    }
                }
            });
            
            // Afficher/masquer le message "aucun r√©sultat"
            if (visibleCount === 0 && searchTerm) {
                noResults.style.display = 'block';
                tbody.style.display = 'none';
            } else {
                noResults.style.display = 'none';
                tbody.style.display = '';
            }
        }
        
        function highlightSearchTerm(row, term) {
            const cells = row.querySelectorAll('td');
            cells.forEach((cell, index) => {
                if (index < 3) { // Ne pas surligner la colonne des liens
                    const originalText = cell.textContent;
                    const regex = new RegExp(`(${escapeRegex(term)})`, 'gi');
                    cell.innerHTML = originalText.replace(regex, '<span class="highlight">$1</span>');
                }
            });
        }
        
        function removeHighlights(row) {
            const highlights = row.querySelectorAll('.highlight');
            highlights.forEach(span => {
                span.outerHTML = span.textContent;
            });
        }
        
        function escapeRegex(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }
        
        function updateStatus(message, type = 'normal') {
            const statusElement = document.getElementById('updateStatus');
            statusElement.className = `update-status ${type}`;
            
            // Mettre √† jour juste la partie status, garder le reste
            const currentText = statusElement.innerHTML;
            const parts = currentText.split('|');
            
            if (parts.length >= 3) {
                const newText = `${message} | ${parts[1]} | ${parts[2]}`;
                statusElement.innerHTML = newText;
            }
        }
        
        function updateCsvStatus(message, type = 'normal') {
            const csvStatusElement = document.getElementById('csvStatus');
            if (csvStatusElement) {
                csvStatusElement.textContent = message;
                csvStatusElement.className = type;
            }
        }
        
        function updateLastUpdateTime() {
            const now = new Date();
            const timeString = now.toLocaleString();
            const lastUpdateSpan = document.getElementById('lastUpdate');
            if (lastUpdateSpan) {
                lastUpdateSpan.textContent = timeString;
            }
        }
        
        function updateNextUpdateTime(time) {
            const nextUpdateSpan = document.getElementById('nextUpdate');
            if (nextUpdateSpan) {
                nextUpdateSpan.textContent = time;
            }
        }
        
        function updateArticleCount() {
            const countSpan = document.getElementById('articleCount');
            if (countSpan) {
                countSpan.textContent = allArticles.length;
            }
        }
        
        function updateIntervalDisplay() {
            const interval = CONFIG.updateInterval;
            let display;
            
            if (interval < 60) {
                display = `Every ${interval} minutes`;
            } else {
                const hours = Math.floor(interval / 60);
                display = `Every ${hours} hour${hours > 1 ? 's' : ''}`;
            }
            
            const intervalSpan = document.getElementById('updateInterval');
            if (intervalSpan) {
                intervalSpan.textContent = display;
            }
        }
        
        // Initialiser l'affichage
        updateIntervalDisplay();
    </script>
</body>
</html>
